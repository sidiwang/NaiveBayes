% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/NaiveBayes.R
\name{NaiveBayes}
\alias{NaiveBayes}
\alias{NaiveBayes.default}
\alias{NaiveBayes.formula}
\alias{print.NaiveBayes}
\alias{predict.NaiveBayes}
\title{NaiveBayes}
\usage{
NaiveBayes(x, ...)

\method{NaiveBayes}{default}(x, y, laplace = 0, ...)

\method{NaiveBayes}{formula}(formula, data, laplace = 0, ...)

\method{print}{NaiveBayes}(x, ...)

\method{predict}{NaiveBayes}(
  object,
  newdata,
  type = c("class", "raw"),
  threshold = 0.001,
  eps = 0,
  ...
)
}
\arguments{
\item{x}{matrix or dataframe with categorical ( character / factor / logical ) or metric ( numeric ) predictors. Please correctly specified data types in each column. No NA is allowed.}

\item{...}{not used}

\item{y}{class vector ( character / factor / logical )}

\item{laplace}{value used for Laplace smoothing ( additive smoothing ). Defaults to 0 ( no Laplace smoothing )}

\item{formula}{users can also input their data via NaiveBayes ( formula, data = ... ) format. A formula of the form "class ~ x1 + x2 + x3 ..." Interactions are not allowed}

\item{data}{Either a datafrom of predictors ( categorical and/or numeric)  or a contigency table.}

\item{object}{a fitted object of class "NaiveBayes"}

\item{newdata}{matrix or dataframe with categorical ( character / factor / logical ) or metric ( numeric ) predictors. Note: if NaiveBayes was used to create the model, then if newdata contains features that were not encountered in the training data, these are omitted from the prediction.}

\item{type}{if "class", new data points are classified according to the highest posterior probabilities. If "raw", the posterior probabilities for each class are returned.}

\item{threshold}{value by which zero probabilities or probabilities within the epsilon-range corresponding to metric variables are replaced ( zero probabilities corresponding to categorical variables can be handled with Laplace ( additive ) smoothing ).}

\item{eps}{value that specifies an epsilon-range to replace zero or close to zero probabilities by \code{threshold}. It applies to metric variables.}
}
\value{
An object of class "NaiveBayes", which has five components:
\itemize{
\item \code{apriori} Class probabilities for the dependent variable
\item \code{results}  A list of tables, one for each predictor variable. For each categorical variable a table giving, for each attribute level, the conditional probabilities given the target class. For each numeric variable, a table giving, for each target class, mean and standard deviation of the variable.
\item \code{predictors}  The list of independent variables
\item \code{call}  The call that produced this object.
\item \code{level}  Levels of the dependent variable
}
}
\description{
This NaiveBayes package provides an efficient implementation of the very popular Naive
Bayes classifier, which assumes independence between the feature variables. The core
classification function is written in Rcpp. Gaussian distribution is used with numerical
variables. Please use 'NaiveBayes (...)' for model fitting, and use 'predict (...)' to obtain its
corresponding predictions.
}
\details{
The general function \bold{\code{NaiveBayes()}} detects the class of each feature in the
dataset and assumes possibly different distribution for each feature. Predict function uses
a NaiveBayes model and a new data set to create the classifications. This can either be the
raw probabilities generated by the NaiveBayes model or the classes themselves.

1. Numeric ( metric ) predictors are handled by assuming that they follow Gaussian distribution, given the class label; Missing values are not included into constructing tables. Logical variables are treated as categorical ( binary ) variables.
2. Prediction function computes conditional posterior probabilities for each lass label using the Bayes' rule under the assumption of independence of predictors. Logical variables are treated as categorical ( binary ) variables.
}
\note{
The class "numeric" contains "double" ( double precision floating point numbers ) and "integer".
Prior the model fittng the classes of columns in the data.frame "data" can be easily checked via:
\itemize{
\item \code{sapply(data, class)}
\item \code{sapply(data, is.numeric)}
\item \code{sapply(data, is.double)}
\item \code{sapply(data, is.integer)}
}
}
\examples{
x = as.matrix(iris[, 1:4])
mymodel1 = NaiveBayes(iris[, 1:4], iris[, 5])
## or
mymodel1_f = NaiveBayes(Species ~. , data = iris)
predict(mymodel1, iris[, 1:4])

x1 <- matrix( rpois(100 * 4, 5), ncol = 4)
x2 <- matrix( rpois(50 * 4, 10), ncol = 4)
x <- rbind(x1, x2)
ina <- c( rep(1, 100), rep(2, 50) )
mymodel2 = NaiveBayes(x, ina)
predict(mymodel2, x)
}
